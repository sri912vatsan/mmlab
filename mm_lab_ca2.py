# -*- coding: utf-8 -*-
"""MM Lab CA2

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/192T8iqNhxbL23r5o1n9woKDbAekK_fdE

# **Worksheet 6**
"""

import pandas as pd
from datetime import datetime

dateparse = lambda x: datetime.strptime(x, '%B-%Y')
data = {}
data['Axis'] = pd.read_csv('/content/drive/MyDrive/SEM-8/CF/SIM/Bank Stocks/Axis.csv', usecols = ['Month', 'Open Price', 'Close Price', 'High Price', 'Low Price'], parse_dates = ['Month'], date_format = '%B-%Y', index_col = 'Month')
data['Federal'] = pd.read_csv('/content/drive/MyDrive/SEM-8/CF/SIM/Bank Stocks/Federal.csv', usecols = ['Month', 'Open Price', 'Close Price', 'High Price', 'Low Price'], parse_dates = ['Month'], date_format = '%B-%Y', index_col = 'Month')
data['Baroda'] = pd.read_csv('/content/drive/MyDrive/SEM-8/CF/SIM/Bank Stocks/Baroda.csv', usecols = ['Month', 'Open Price', 'Close Price', 'High Price', 'Low Price'], parse_dates = ['Month'], date_format = '%B-%Y', index_col = 'Month')
data['SBI'] = pd.read_csv('/content/drive/MyDrive/SEM-8/CF/SIM/Bank Stocks/SBI.csv', usecols = ['Month', 'Open Price', 'Close Price', 'High Price', 'Low Price'], parse_dates = ['Month'], date_format = '%B-%Y', index_col = 'Month')
data['HDFC'] = pd.read_csv('/content/drive/MyDrive/SEM-8/CF/SIM/Bank Stocks/HDFC.csv', usecols = ['Month', 'Open Price', 'Close Price', 'High Price', 'Low Price'], parse_dates = ['Month'], date_format = '%B-%Y', index_col = 'Month')
data['ICICI'] = pd.read_csv('/content/drive/MyDrive/SEM-8/CF/SIM/Bank Stocks/ICICI.csv', usecols = ['Month', 'Open Price', 'Close Price', 'High Price', 'Low Price'], parse_dates = ['Month'], date_format = '%B-%Y', index_col = 'Month')
data['PNB'] = pd.read_csv('/content/drive/MyDrive/SEM-8/CF/SIM/Bank Stocks/PNB.csv', usecols = ['Month', 'Open Price', 'Close Price', 'High Price', 'Low Price'], parse_dates = ['Month'], date_format = '%B-%Y', index_col = 'Month')
data['KotakMahindra'] = pd.read_csv('/content/drive/MyDrive/SEM-8/CF/SIM/Bank Stocks/KotakMahindra.csv', usecols = ['Month', 'Open Price', 'Close Price', 'High Price', 'Low Price', 'High Price', 'Low Price'], parse_dates = ['Month'], date_format = '%B-%Y', index_col = 'Month')

"""## Probability Stock Goes Up or Down


"""

import numpy as np

upPercent = {}
downPercent = {}
upProb = {}
downProb = {}

for ticker in data:
    n = len(data[ticker]['Close Price'])
    upPercent[ticker] = np.mean((data[ticker]['High Price'] - data[ticker]['Open Price']) / data[ticker]['Open Price'])
    downPercent[ticker] = np.mean((data[ticker]['Open Price'] - data[ticker]['Low Price']) / data[ticker]['Open Price'])
    upProb[ticker] = 0
    downProb[ticker] = 0
    for i in range(n - 1):
        if data[ticker]['Close Price'].iloc[i + 1] > data[ticker]['Close Price'].iloc[i]:
            upProb[ticker] += 1
        else:
            downProb[ticker] += 1
    upProb[ticker] /= n - 1
    downProb[ticker] /= n - 1

print("Average percentage of going up:")
print(upPercent)
print("Average percentage of going down:")
print(downPercent)
print("Probability of going up:")
print(upProb)
print("Probability og goin down:")
print(downProb)

"""## Risk and Return"""

for ticker in data:
    data[ticker]['RoR'] = (data[ticker]['Close Price'] - data[ticker]['Open Price']) / data[ticker]['Open Price']

mu = np.array([data[ticker]['RoR'].mean() for ticker in data])
sigma = np.array([data[ticker]['RoR'].std() for ticker in data])

print("Returns:", mu)
print("Risk:", sigma)

"""## Correlation"""

correlation = np.corrcoef([data[ticker]['RoR'] for ticker in data])

print("Correlation Matrix:")
print(pd.DataFrame(correlation, columns = data.keys(), index = data.keys()))

"""## Minimum  Variance Portfolio"""

from scipy.optimize import minimize
import math

def weightConstraint(weights):
    return np.sum(weights) - 1.0

def minObjectiveFun(weights, covMatrix):
    return np.dot(weights, np.dot(covMatrix, weights))

def minVar(mu, cov):
    print("Minimizing Risk")
    initialWeights = np.ones(len(mu)) / len(mu)
    constraints = ({'type': 'eq', 'fun': weightConstraint})
    result = minimize(minObjectiveFun, initialWeights, args = (cov), method = 'SLSQP', constraints = constraints)
    optimalWeights = result.x

    print("Optimal Weights:", result.x)
    print("Portfolio Risk:", math.sqrt(result.fun))
    print('Portfolio Expected Return:', np.dot(optimalWeights, mu))

    return optimalWeights, math.sqrt(result.fun), np.dot(optimalWeights, mu)

covMatrix = np.array(np.cov([data[ticker]['RoR'] for ticker in data]))
mvp = minVar(mu, covMatrix)

"""## Regression Line between Open and LTP"""

from sklearn.linear_model import LinearRegression
import matplotlib.pyplot as plt

fig, axes = plt.subplots(4, 2, figsize = (25, 50))
axes = axes.ravel()

for i, ticker in enumerate(data):
    X = data[ticker]['Open Price'].values.reshape(-1, 1)
    Y = data[ticker]['Close Price'].values.reshape(-1, 1)
    reg = LinearRegression().fit(X, Y)
    axes[i].scatter(X, Y, label = 'Actual', s = 2)
    axes[i].plot(X, reg.predict(X), color = 'red', label = 'Predicted')
    axes[i].set_title(ticker)
    axes[i].set_xlabel('Open')
    axes[i].set_ylabel('LTP')
    axes[i].legend()

plt.tight_layout()
plt.show()

"""## Beta Values"""

def covariance(x, y):
    n = len(x)
    meanX = np.mean(x)
    meanY = np.mean(y)
    total = 0
    for i in range(n):
        total += (x[i] - meanX) * (y[i] - meanY)
    return total / n

beta = {}
betaV = 0

for i, ticker in enumerate(data):
    X = list(data[ticker]['RoR'])
    Y = list(data['ICICI']['RoR'])

    beta[ticker] = covariance(X, Y) / np.var(Y)
    betaV += mvp[0][i] * beta[ticker]

print("Beta Values:")
print(beta)
print("Beta Value of MVP:", betaV)

"""## Risk-Return Graph"""

plt.scatter(mvp[1], mvp[2], label = 'Min Risk', marker = 'o')
for i, ticker in enumerate(data):
    plt.scatter(sigma[i], mu[i], label = ticker, marker = 'x')
plt.grid(True)
plt.xlabel('Risk')
plt.ylabel('Return')
plt.legend(bbox_to_anchor=(1.1, 1.05))
plt.title('Risk-Return Graph')
plt.show()

"""## Expected Return using CAPM"""

riskFreeRate = 0.06

expReturn = riskFreeRate + betaV * (np.mean(data['ICICI']['RoR']) - riskFreeRate)
print("Expected Return of the Portfolio: ", expReturn * 100, "%", sep = '')

"""# **Worksheet 7**"""

import pandas as pd
from datetime import datetime

dateparse = lambda x: datetime.strptime(x, '%B-%Y')
data = {}
data['Axis'] = pd.read_csv('/content/drive/MyDrive/SEM-8/CF/SIM/Bank Stocks/Axis.csv', usecols = ['Month', 'Open Price', 'Close Price', 'High Price', 'Low Price'], parse_dates = ['Month'], date_format = '%B-%Y', index_col = 'Month')
data['Federal'] = pd.read_csv('/content/drive/MyDrive/SEM-8/CF/SIM/Bank Stocks/Federal.csv', usecols = ['Month', 'Open Price', 'Close Price', 'High Price', 'Low Price'], parse_dates = ['Month'], date_format = '%B-%Y', index_col = 'Month')
data['Baroda'] = pd.read_csv('/content/drive/MyDrive/SEM-8/CF/SIM/Bank Stocks/Baroda.csv', usecols = ['Month', 'Open Price', 'Close Price', 'High Price', 'Low Price'], parse_dates = ['Month'], date_format = '%B-%Y', index_col = 'Month')
data['SBI'] = pd.read_csv('/content/drive/MyDrive/SEM-8/CF/SIM/Bank Stocks/SBI.csv', usecols = ['Month', 'Open Price', 'Close Price', 'High Price', 'Low Price'], parse_dates = ['Month'], date_format = '%B-%Y', index_col = 'Month')
data['HDFC'] = pd.read_csv('/content/drive/MyDrive/SEM-8/CF/SIM/Bank Stocks/HDFC.csv', usecols = ['Month', 'Open Price', 'Close Price', 'High Price', 'Low Price'], parse_dates = ['Month'], date_format = '%B-%Y', index_col = 'Month')
data['ICICI'] = pd.read_csv('/content/drive/MyDrive/SEM-8/CF/SIM/Bank Stocks/ICICI.csv', usecols = ['Month', 'Open Price', 'Close Price', 'High Price', 'Low Price'], parse_dates = ['Month'], date_format = '%B-%Y', index_col = 'Month')
data['PNB'] = pd.read_csv('/content/drive/MyDrive/SEM-8/CF/SIM/Bank Stocks/PNB.csv', usecols = ['Month', 'Open Price', 'Close Price', 'High Price', 'Low Price'], parse_dates = ['Month'], date_format = '%B-%Y', index_col = 'Month')
data['KotakMahindra'] = pd.read_csv('/content/drive/MyDrive/SEM-8/CF/SIM/Bank Stocks/KotakMahindra.csv', usecols = ['Month', 'Open Price', 'Close Price', 'High Price', 'Low Price', 'High Price', 'Low Price'], parse_dates = ['Month'], date_format = '%B-%Y', index_col = 'Month')

"""## I/II"""

for ticker in data:
    data[ticker]['RoR'] = (data[ticker]['Close Price'] - data[ticker]['Open Price']) / data[ticker]['Open Price']

mu = np.array([data[ticker]['RoR'].mean() for ticker in data])
sigma = np.array([data[ticker]['RoR'].std() for ticker in data])

print("Returns:", mu)
print("Risk:", sigma)

"""## III"""

import numpy as np
import matplotlib.pyplot as plt

def portfolioPerformance(weights, mu, cov):
  returns = np.dot(weights, mu)
  std = np.sqrt(np.dot(weights.T, np.dot(cov, weights)))
  return returns, std

def generatePortfolios(n, mu, cov, rf):
  results = np.zeros((3, n))

  for i in range(n):
    weights = np.random.random(len(mu))
    weights /= np.sum(weights)
    mu_, sigma_ = portfolioPerformance(weights, mu, cov)
    results[0,i] = mu_
    results[1,i] = sigma_
    results[2,i] = (mu_ - rf) / sigma_  # Sharpe Ratio

  return results


results = generatePortfolios(1000, mu, covMatrix, 0.06)

# Plotting the efficient frontier
plt.figure(figsize=(10, 6))
plt.scatter(results[0,:], results[1,:], c=results[2,:], marker='o')
plt.xlabel('Portfolio Standard Deviation (Risk)')
plt.ylabel('Portfolio Return')
plt.title('Efficient Frontier')
plt.colorbar(label='Sharpe Ratio')
plt.show()

"""Max Sharpe Ratio Portfolio"""

def sharpeRatio(weights, mu, cov, rf):
    returns = np.dot(weights, mu)
    std = np.sqrt(np.dot(weights.T, np.dot(cov, weights)))
    return (returns - rf) / std

def maxSharpeRatio(mu, cov, rf):
    n = len(mu)
    initialWeights = np.ones(n) / n
    constraints = ({'type': 'eq', 'fun': weightConstraint})
    bounds = [(0, 1) for i in range(n)]
    result = minimize(lambda weights: -sharpeRatio(weights, mu, cov, rf), initialWeights, method = 'SLSQP', bounds = bounds, constraints = constraints)
    return result.x

maxSharpePortfolio = maxSharpeRatio(mu, covMatrix, 0.06)
print("Max Sharpe Ratio Portfolio:", maxSharpePortfolio)

"""Value at Risk"""

# Historical Simulation
portfolioReturns = np.dot(mvp[0], [data[ticker]['RoR'] for ticker in data])
var1 = np.percentile(portfolioReturns, 5)

# Parametric VaR
portfolioSTD = mvp[1]
var2 = portfolioReturns.mean() - 1.645 * portfolioSTD

print("Historical Simulation VaR:", var1)
print("Parametric VaR:", var2)

"""# **Worksheet 8**

## Q1
"""

import matplotlib.pyplot as plt
import numpy as np

def dotMatrix(seq1, seq2, windowSize, threshold):
    matrix = np.zeros((len(seq1) - windowSize + 1, len(seq2) - windowSize + 1))
    for i in range(len(seq1) - windowSize + 1):
        for j in range(len(seq2) - windowSize + 1):
            if sum([1 for k in range(windowSize) if seq1[i + k] == seq2[j + k]]) >= threshold:
                matrix[i, j] = 1
    return matrix

def dotMatrix2(seq1, seq2, windowSize, threshold):
    seq1Arr = np.array(list(seq1))
    seq2Arr = np.array(list(seq2))
    matrix = np.zeros((len(seq1) - windowSize + 1, len(seq2) - windowSize + 1))

    for i in range(len(seq1) - windowSize + 1):
        for j in range(len(seq2) - windowSize + 1):
            if np.sum(seq1Arr[i: i + windowSize] == seq2Arr[j: j + windowSize]) >= threshold:
                matrix[i, j] = 1

    return matrix

seq = "AGCTTAGCTAGGCTAATCGGATCGGCTTAGCTAAGCTTAGGCT"
windowSize = 4
threshold = 3
matrix = dotMatrix(seq, seq, windowSize, threshold)

plt.imshow(matrix, cmap = 'binary')
plt.xlabel("Sequence 1")
plt.ylabel("Sequence 2")
plt.title("Dot Matrix Plot")
plt.show()

def reverseComplement(seq):
    complement = {'A': 'T', 'T': 'A', 'C': 'G', 'G': 'C'}
    return ''.join([complement[base] for base in seq[::-1]])

seq = "AGCTTAGCTAGGCTAATCGGATCGGCTTAGCTAAGCTTAGGCT"
windowSize = 4
threshold = 3
revCompSeq = reverseComplement(seq)
matrix = dotMatrix(seq, revCompSeq, windowSize, threshold)

plt.imshow(matrix, cmap = 'binary')
plt.xlabel("Sequence")
plt.ylabel("Reverse Complement Sequence")
plt.title("Dot Matrix Plot (Inverted Repeats)")
plt.show()

seq = "AGCTTAGCTAGGCTAATCGGATCGGCTTAGCTAAGCTTAGGCT"
windowSize = 5
threshold = 4
revCompSeq = reverseComplement(seq)
matrix1 = dotMatrix(seq, seq, windowSize, threshold)
matrix2 = dotMatrix(seq, revCompSeq, windowSize, threshold)

fig, axes = plt.subplots(1, 2, figsize = (10, 5))

axes[0].imshow(matrix1, cmap = 'binary')
axes[0].set_xlabel("Sequence")
axes[0].set_ylabel("Sequence")
axes[0].set_title("Dot Matrix Plot")

axes[1].imshow(matrix2, cmap = 'binary')
axes[1].set_xlabel("Sequence")
axes[1].set_ylabel("Reverse Complement Sequence")
axes[1].set_title("Dot Matrix Plot (Inverted Repeats)")

plt.tight_layout()
plt.show()

"""## Q2"""

import matplotlib.pyplot as plt
import numpy as np

# dogSeq = "ATGCTTTTTATCTTTAACTTCTTGTTTTCCCCACTTCCAACCCCGGCACTAATCTGCATCCTGACCTTTGGAGCCGCCATCTTCCTGTGGTTGATCAATAGACCTCAGCCCGTCTTGCCTTTTGTGGATTTGGACAACCAGTCGGTGGGAATTGAGGGAGGGGCACGGAAGGGTACTGGCCAGAAGACCAATGACCCACTGTGTTACTACTACTCAGATGTCAAGACAATGTATGACGTTTTCCAAAGAGGACTTGCTGTGTCTGACAATGGGCCTTGCTTGGGATATAGAAAACCAAACCAGCCCTACAAATGGCTGTCCTACAGGCAGGTGTCTGATCGCGCAGAGTACCTGGGCTCCTGTCTCTTGCATAAAGGATATGAGCCATCATCCGACCAATCTGTTGGCATCTTTGCTCAGAATAGGCCAGAGTGGATCATCTCCGAGTTGGCTTGTTACACATACTCCATGGTAGCCGTCCCCCTGTATGACACCTTGGGAGCAGAAGCCATCATATACATTGTCAACAAGGCTGATATCGCCGCAGTGATCTGTGATACTCCCCAAAAGGCATCAACCCTGATAGAGAATATGGAGAAGGGCCTCACCCCGGGCTTGAAAATGATCATCCTCATGGATCCCTTTGAGGATGACCTGAAGGAAAGAGCAGAGAAATGTGGAATTGAGATCTTATCTCTGTTTGATGCGGAGATTCTAGGCAAAGAGAACTTCAGAAAACCTGTGCCTCCTAGACCAGAAGACCTGAGTATCATCTGCTTTACTAGTGGGACCACAGGTGACCCTAAAGGAGCCATGCTGACCCATCAAAATATTATTTCAAATGTTTCTTCTTTCCTCAAATGTATGGAGTATACTTTCAAGCCCACCCCTGAAGATGTGACCATATCCTACCTGCCCTTGGCTCATATGTTTGAGAGGATTGTACAGGCTGTTATATATTCTTGTGGTGCCAGAGTTGGTTTCTTCCAAGGAGATATTCGGTTGCTACCTGAGGACCTGAAAACTCTAAAGCCCACACTTTTTCCTTCTGTGCCTCGACTACTCAACAGGATCTATGATAAGGTACAAAATGAAGCCAAGACACCCTTGAAGAAGTTTTTATTGAACTTGGCTATTTCCTGTAAATTCAATGAAGTGAAAAAGGGTATCATCAGGCGTGACAGTATTTGGGACAAGCTCATCTTTGCAAAGATCCAGGCCACCCTTGGAGGGAGAATAAACTTTGTGGTTACTGGAGCCGCCCCCATCTCTTCTCCAGTCCTGATGTTCCTCCGGGCAGCGCTGGGATGTCCGGTGTTCGAAGCTTATGGTCAAACAGAATGCACCGCTGGCTGTACATTTACATCACCTGGGGACTGGACATCAGGGCATGTTGGAGTCCCCCTGGCTTGCAATCATGTGAAGCTAGAAGATGTACCTGACATGAACTACTTTTCAGTGAACAATGAAGGAGAGATCTGCATCAAGGGCAGCAATGTGTTCAAAGGATACCTGAAGGATCCTGAGAAAACCAAGGAAGCTCTGGATGAGGATGGCTGGCTTCACACAGGAGACATTGGTCGTTGGCTCCCGAATGGAACTCTGAAGATCATTGACCGTAAAAAGAACATTTTCAAGCTGGCCCAAGGAGAATACATTGCTCCAGAGAAGATAGAAAATATCTACATCAGGAGTAGACCAGTGTCACAAATTTTTGTGCACGGGGACAGCTTACGGTCCTCCTTAGTGGGAGTGGTGGTTCCTGACCCAGAAGTACTGCCATCATTTGTAGCCAAACTTGGGGTTAAAGGCTCCCTCGAAGAACTGTGCAAAAACAATAATGTAAGGGAAGCCATTTTAGAAGACTTGCAGAAAGTTGGGAAAGACGGTGGTCTTAAGTCCTTTGAGCAGGTCAAAAACATCTTTCTTCAACTAGAGCCATTTTCCATTGAAAATGGACTCTTGACACCAACACTGAAAGCAAAGCGGGGAGAGCTTTCCAAGTACTTTCGAACCCAAATCAACAGCCTGTATGAGAACATCCAGGAGTAG"
# dogSeq = "AGCTTAGCTAGGCTAATCGGATCGGCTTAGCTAAGCTTAGGCT"
dogSeq = "AGCGAAAGC"

def dotMatrix(seq1, seq2, windowSize, threshold):
    matrix = np.zeros((len(seq1) - windowSize + 1, len(seq2) - windowSize + 1))
    for i in range(len(seq1) - windowSize + 1):
        for j in range(len(seq2) - windowSize + 1):
            if sum([1 for k in range(windowSize) if seq1[i + k] == seq2[j + k]]) >= threshold:
                matrix[i, j] = 1
    return matrix

def reverseComplement(seq):
    complement = {'A': 'T', 'T': 'A', 'C': 'G', 'G': 'C'}
    return ''.join([complement[base] for base in seq[::-1]])

revCompSeq = reverseComplement(dogSeq)
windowSize = 1
threshold = 1

matrix1 = dotMatrix(dogSeq, dogSeq, windowSize, threshold)
matrix2 = dotMatrix(dogSeq, revCompSeq, windowSize, threshold)

fig, axes = plt.subplots(1, 2, figsize = (10, 5))

axes[0].imshow(matrix1, cmap = 'binary')
axes[0].set_xlabel("Sequence")
axes[0].set_ylabel("Sequence")
axes[0].set_xticks(list(range(9)))
axes[0].set_yticks(list(range(9)))
axes[0].set_xticklabels(list(dogSeq))
axes[0].set_yticklabels(list(dogSeq))
axes[0].set_title("Dot Matrix Plot")
axes[0].add_patch(plt.Rectangle((-0.5, -0.5), 5, 5, fill = False, edgecolor = 'red', linewidth = 2, label = 'Palindrome 1'))
axes[0].add_patch(plt.Rectangle((1.5, 1.5), 7, 7, fill = False, edgecolor = 'navy', linewidth = 2, label = 'Palindrome 2'))
axes[0].legend()

axes[1].imshow(matrix2, cmap = 'binary')
axes[1].set_xlabel("Sequence")
axes[1].set_ylabel("Reverse Complement Sequence")
axes[1].set_xticks(list(range(9)))
axes[1].set_yticks(list(range(9)))
axes[1].set_xticklabels(list(dogSeq))
axes[1].set_yticklabels(list(revCompSeq))
axes[1].set_title("Dot Matrix Plot (Inverted Repeats)")

plt.tight_layout()
plt.show()

"""* For **perfectly aligned sequences** there is a *diagonal formation* of dot plot.
* For **palindromic sequences** i. e. for sequences that are symmetrical from the midpoint of the sequence, there exist *2 intersecting diagonals* on the plot.
* Self -complementarity of DNA sequences (also called **inverted repeats**), for example, those that form the stems of a hairpin structure, can also be identiﬁed using a dot plot. In this case, a DNA sequence is compared with its reverse-complemented sequence. *Parallel diagonals* represent the inverted repeats.

# **Practice**
"""

import numpy as np
import matplotlib.pyplot as plt

def revComp(seq):
    complement = {'A': 'T', 'T': 'A', 'C': 'G', 'G': 'C'}
    return ''.join([complement[i] for i in seq[::-1]])

def dotMatrix(seq1, seq2, windowSize, threshold):
    seq1 = np.array(list(seq1))
    seq2 = np.array(list(seq2))
    matrix = np.zeros((len(seq1) - windowSize + 1, len(seq2) - windowSize + 1))

    for i in range(len(seq1) - windowSize + 1):
        for j in range(len(seq2) - windowSize + 1):
            if np.sum(seq1[i: i + windowSize] == seq2[j: j + windowSize]) >= threshold:
                matrix[i, j] = 1
    return matrix

seq = "AGCTAGTCGATCGATCGATCCGAATCGAAATCGATCACGA"

# matrix = dotMatrix(seq, revComp(seq), 1, 1)
matrix = dotMatrix(seq, seq, 1, 1)

plt.imshow(matrix, cmap = 'binary')
plt.xlabel("Sequence 1")
plt.ylabel("Sequence 2")
plt.show()

import pandas as pd
from datetime import datetime

data = {}
data['Axis'] = pd.read_csv('/content/drive/MyDrive/SEM-8/CF/SIM/Bank Stocks/Axis.csv', usecols = ['Month', 'Close Price', 'Open Price', 'High Price', 'Low Price'], parse_dates = ['Month'], date_format = '%B-%Y', index_col = 'Month')
data['Federal'] = pd.read_csv('/content/drive/MyDrive/SEM-8/CF/SIM/Bank Stocks/Federal.csv', usecols = ['Month', 'Open Price', 'Close Price', 'High Price', 'Low Price'], parse_dates = ['Month'], date_format = '%B-%Y', index_col = 'Month')
data['Baroda'] = pd.read_csv('/content/drive/MyDrive/SEM-8/CF/SIM/Bank Stocks/Baroda.csv', usecols = ['Month', 'Open Price', 'Close Price', 'High Price', 'Low Price'], parse_dates = ['Month'], date_format = '%B-%Y', index_col = 'Month')
data['SBI'] = pd.read_csv('/content/drive/MyDrive/SEM-8/CF/SIM/Bank Stocks/SBI.csv', usecols = ['Month', 'Open Price', 'Close Price', 'High Price', 'Low Price'], parse_dates = ['Month'], date_format = '%B-%Y', index_col = 'Month')
data['HDFC'] = pd.read_csv('/content/drive/MyDrive/SEM-8/CF/SIM/Bank Stocks/HDFC.csv', usecols = ['Month', 'Open Price', 'Close Price', 'High Price', 'Low Price'], parse_dates = ['Month'], date_format = '%B-%Y', index_col = 'Month')
data['ICICI'] = pd.read_csv('/content/drive/MyDrive/SEM-8/CF/SIM/Bank Stocks/ICICI.csv', usecols = ['Month', 'Open Price', 'Close Price', 'High Price', 'Low Price'], parse_dates = ['Month'], date_format = '%B-%Y', index_col = 'Month')
data['PNB'] = pd.read_csv('/content/drive/MyDrive/SEM-8/CF/SIM/Bank Stocks/PNB.csv', usecols = ['Month', 'Open Price', 'Close Price', 'High Price', 'Low Price'], parse_dates = ['Month'], date_format = '%B-%Y', index_col = 'Month')
data['KotakMahindra'] = pd.read_csv('/content/drive/MyDrive/SEM-8/CF/SIM/Bank Stocks/KotakMahindra.csv', usecols = ['Month', 'Open Price', 'Close Price', 'High Price', 'Low Price'], parse_dates = ['Month'], date_format = '%B-%Y', index_col = 'Month')